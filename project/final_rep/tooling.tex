\section{Tool Implementation}

\ctVerif is an open-source implementation of the constant-time verifier we
described earlier in \secref{body}. \figref{ct-verif-flow} illustrates the
tool flow from top to bottom. To prove constant-time security, a C function is
instantiated in a proof harness that declares public inputs (and outputs). Then,
the function alongside harness are compiled down to \codetext{llvm} bitcode. The
bitcodes are linked together and and then converted to \emph{Boogie Programming
Language} (\codetext{.bpl}). Compilation down to \codetext{.bpl} is automated
through \emph{SMACK}\cite{smack}, but it is possible to customize the flow if
needed and only rely on the the \codetext{bitcode} to \codetext{bpl} conversion
of SMACK.

The linked \codetext{bpl} files is then fed to \emph{BAM! BAM! Boogieman} which
performs the key task of generating the self-product (see \secref{body}), and
finally the self-product---which contains assertions and assumptions---is
given to \emph{Boogie}\cite{boogie} to verify safety of the self-product.


\begin{figure}[h]
    \centering
    \includegraphics[height=0.4\textheight]{figs/ct-verif-flow.pdf}
    \caption{\ctVerif tool flow}
    \label{fig:ct-verif-flow}
\end{figure}




To ensure the tool works as advertised, we first tried proving/disproving
small examples with obvious answers and then moved to reproducing the
results reported in the paper\cite{almeida}.


\subsection{Handling toy programs}

We started by disproving constant-timeness of the code given in \figref{example}.
\ctVerif correctly identifies this code as unsafe (i.e., not constant-time).
The test harness for this examples is a simple wrapper that declares all inputs
as public except \codetext{l\_idx} (see )

\begin{figure}[h]
    \centering\resizebox{0.7\columnwidth}{!}{\lstinputlisting[language=C]{code/example_wrapper.c}}
    \caption{Proof harness for sub-array copy in \figref{example}}
    \label{fig:example_wrapper}
\end{figure}

A more interesting example is the slightly unusual \codetext{vector\_add}
function in \figref{vector_add}. Notice how by declaring \codetext{a[N - 1]} as
a public input we make the code constant time. Indeed \ctVerif  also correctly
identifies this code as constant time. Now if we remove the public input
declaration on line 10, then the code will no longer be constant time because the
for loop will leak the length of arrays and \ctVerif also correctly marks the
program as non-constant time.

\begin{figure}[h]
    \centering\resizebox{0.7\columnwidth}{!}{\lstinputlisting[language=C]{code/vector_add.c}}
    \caption{A slightly unusual vector addition}
    \label{fig:vector_add}
\end{figure}


\subsection{Reproducing results}


We set out to reproduce all the results in the paper, however, we ended up
only verifying some of them. There were two reasons:
\begin{enumerate}
    \item Functions reported as constant time in the paper could not be proven
    to be constant-time using
    \item The reported functions could not be found in the \ctVerif repository
    or their build procedure were broken/incomplete.
\end{enumerate}

\subsubsection{\codetext{tea}}
\codetext{tea} is a tiny encryption algorithm that consists of about 20 lines
of code. We successfully verified \codetext{tea} to be constant-time.



\subsection{\codetext{libfixedpointfixedtime}} \codetext{libfixedpointfixedtime}
is a library that implements a large variety of fixed-point arithmetic
operations in constant-time. We successfully verified constant-timeness for 34
functions:
\codetext{fix\_is\_neg},
\codetext{fix\_is\_nan},
\codetext{fix\_is\_inf\_pos},
\codetext{fix\_is\_inf\_neg},
\codetext{fix\_eq},
\codetext{fix\_eq\_nan},
\codetext{fix\_ne},
\codetext{fix\_cmp},
\codetext{fix\_le},
\codetext{fix\_ge},
\codetext{fix\_lt},
\codetext{fix\_gt},
\codetext{fix\_neg},
\codetext{fix\_abs},
\codetext{fix\_add},
\codetext{fix\_sub},
\codetext{fix\_mul},
\codetext{fix\_div},
\codetext{fix\_floor},
\codetext{fix\_ceil},
\codetext{fix\_ln},
\codetext{fix\_log2},
\codetext{fix\_log10},
\codetext{fix\_convert\_from\_int64},
\codetext{fix\_convert\_to\_int64},
\codetext{fix\_round\_up\_int64},
\codetext{fix\_ceil64},
\codetext{fix\_floor64},
\codetext{fix\_sin},
\codetext{fix\_cos},
\codetext{fix\_tan},
\codetext{fix\_exp},
\codetext{fix\_sqrt},
\codetext{fix\_pow}.
Whereas the paper only reports 10 functions among the ones we verified.

\subsubsection{\codetext{curve25519-donna}} We successfully re-verified the C
implementation of \codetext{curve25519-donna} elliptic curve. This function
was the hardest among others and took the longest time (about 7 minutes).


\subsubsection{\codetext{libsodium}} \codetext{libsodium} is an easy-to-use
encryption library. We attempted to verify 4 functions, \codetext{chacha20,
salsa20, sha256, sha512} from \codetext{libsodium}. We used the Makefiles
provided by \ctVerif which isolates the C files used by each function (i.e., the
whole llibrary is not compiled to \codetext{llvm} bitcode). We successfully
reproduced the paper results by verifying constant-timeness of
\codetext{chacha20} and \codetext{salsa20} but failed prove it for
\codetext{sha256} and \codetext{sha512} (unlike what the paper claims).


Upon inspecting the C implementation of \codetext{sha256} and \codetext{sha512}
we couldn't identify exactly why these two functions are not constant-time.
This implored us look for other methods of asserting constant-timeness which
we will follows in ....



\subsection{Scalability of \ctVerif}

To evaluate the scalability of this tool we first tried to verify
constant-timeness of \codetext{s2n\_verify\_cbc} from Amazon's
\codetext{libs2n}. The test harness for this function is included as one of the
examples in the \ctVerif repository but it had a simple bug in which the test
harness was calling itself instead of the \codetext{s2n\_verify\_cbc} function.
However, there was no build script for this specific function and modified the
\codetext{Makefile}s in the \codetext{libs2n} library to generate
\codetext{llvm} bitcode instead of binary. We then manually linked the bitcode
library with the test harness and invoked \codetext{llvm2bpl} pass---provided by
SMACK---and fed the generated \codetext{.bpl} files to BAM! BAM! Boogie to
generate the program product. Unfortunately. \codetext{llvml2pl} resulted in
many warnings regarding memory safety and self-product program generation failed
to due an resolved reference.


In another attempt, we compiled the OpenSSL library down to \codetext{llvm}
bitcode to verify the SHA-1 function. Transformation from bitcode to bpl
resulted in over 70GiB of memory usage and did not terminate after 30 minutes.


Unlike the functions verified in the paper, these two functions them are
isolated and the bitcode given to \ctVerif contains unused code. It seems like
SMACK transforms the whole program irrespective of the target function. This
approach limits the usability of \ctVerif since verifications requires a good
understanding of the underlying library structure to be able to isolate the used
code.

